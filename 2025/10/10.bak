from copy import deepcopy
import time
import itertools
from collections import Counter

with open("input3", "r") as fp:
    lines = [line.strip() for line in fp]


silver = 0
for k, line in enumerate(lines):
    a, b = line.split(']')
    b, c = b.split('{')

    a = a[1:]
    b = b.strip().split()
    b = [[int(x) for x in y[1:-1].split(',')] for y in b]
    c = [int(x) for x in c[:-1].split(',')]

    start_a = '.' * len(a)

    DP = []
    queue = [[0, [], start_a]]
    z = 0
    while queue:
        i, prev_buttons, lights = queue.pop(0)
        
        found = False
        for button in b:
            new_lights = ''
            for j in range(len(lights)):
                if j in button:
                    if lights[j] == '.':
                        new_lights += '#'
                    else:
                        new_lights += '.'
                else:
                    new_lights += lights[j]
        
            if new_lights == a:
                # print(prev_buttons + [button])
                silver += i + 1
                found = True
            else:
                if new_lights not in DP:
                    DP.append(new_lights)
                    queue.append([i + 1, prev_buttons + [button], new_lights])

            # if found:
            #     break
        if found:
            break

print(silver)

b = []
c = []

def find_new_buttons(done_buttons, curr_state):
    global b
    global c

    # print(b, c)

    new_set_buttons = []

    min_val = 999999999
    min_states = []
    # print(curr_state, c)
    for i, (cs, es) in enumerate(zip(curr_state, c)):
        if cs != es and (es - cs) < min_val:
            min_states = [i]
            min_val = es - cs
        elif cs != es and es == min_val:
            min_states.append(i)
            min_val = es - cs

    # print(min_states, min_val)

    for ms in min_states:
        new_set = []
        for btn in b:
            if btn not in done_buttons and ms in btn:
                new_set.append(btn)

        new_set_buttons.append(new_set)
    return (new_set_buttons, min_val)

fewest_buttons = 999999999
def recursion(i, set_buttons, done_buttons, curr_state):
    global b
    global c
    global fewest_buttons

    # print("i, set_buttons, done_buttons, curr_state")
    # print(i, set_buttons, done_buttons, curr_state)
    # input()

    if i >= fewest_buttons:
        return 999999999

    if curr_state == c:
        print(f"new fewest: {i}")
        fewest_buttons = i
        return i

    if len(set_buttons) == 0:
        (new_set_buttons, jump) = find_new_buttons(done_buttons, curr_state)
    else: 
        assert(False)

    result = 999999999
    for sbs in new_set_buttons:
        # print(sbs)

        if len(sbs) == 0:
            continue

        try:
            combinations = list(itertools.combinations_with_replacement(sbs, jump))
            # print("jump, len(combinations)")
            # print(jump, len(combinations))
        except:
            print("jump, sbs")
            print(jump, sbs)
            assert("False")

        for combo in combinations:

            new_curr_state = deepcopy(curr_state)
            for sb in combo:
                # print(sb)
                for state in sb:
                    new_curr_state[state] += 1

            # print("i + jump, [], done_buttons + sbs, new_curr_state")
            # print(i + jump, [], done_buttons + sbs, new_curr_state)
            # continue
            tmp = recursion(i + jump, [], done_buttons + sbs, new_curr_state)
            if tmp < result:
                result = tmp


    # print(f"result: {result}, {i}")
    return result

gold = 0
for k, line in enumerate(lines):
    print(k)
    a, b = line.split(']')
    b, c = b.split('{')

    a = a[1:]
    b = b.strip().split()
    b = [[int(x) for x in y[1:-1].split(',')] for y in b]
    c = [int(x) for x in c[:-1].split(',')]

    # if we sort the buttons in order of largest to smallest, we should increase performance
    # not enough
    # b = sorted(b, key=len, reverse=True)

    # print(a, b, c)
    # exit(0)
    
    curr_state = [0] * len(c)
    
    # reset globals
    fewest_buttons = 999999999
    print(b, c)
    start_time = time.perf_counter()
    tmp = recursion(0, [], [], curr_state)
    print(tmp, time.perf_counter() - start_time)
    print()
    # exit(0)

    gold += tmp


print("GOLD")
print(gold)